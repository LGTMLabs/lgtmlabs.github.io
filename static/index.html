<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LGTM Labs</title>
    <meta name="description" content="LGTM Labs is a Quality Engineering lab focused on the intersection of technology and testing, producing innovative open source products.">
    <meta property="og:title" content="LGTM Labs">
    <meta property="og:description" content="Quality Engineering at the Intersection of Tech & Testing">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <canvas id="particles"></canvas>
    
    <main class="content">
        <h1 class="brand">LGTM Labs</h1>
        <a href="mailto:contact@lgtmlabs.com" class="contact">contact@lgtmlabs.com</a>
    </main>

    <script>
        // Conway's Game of Life with mouse gravity effect
        const canvas = document.getElementById('particles');
        const ctx = canvas.getContext('2d');
        
        let cellSize = 4;
        let cols, rows;
        let grid, nextGrid;
        let mouseX = 0;
        let mouseY = 0;
        let colorCycle = 0;
        let frameCount = 0;
        
        // Cell ages for color effects
        let cellAges;
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initGrid();
        }
        
        function initGrid() {
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            
            grid = new Array(cols);
            nextGrid = new Array(cols);
            cellAges = new Array(cols);
            
            for (let i = 0; i < cols; i++) {
                grid[i] = new Array(rows);
                nextGrid[i] = new Array(rows);
                cellAges[i] = new Array(rows);
                
                for (let j = 0; j < rows; j++) {
                    // Random initial state with low density
                    grid[i][j] = Math.random() > 0.92 ? 1 : 0;
                    nextGrid[i][j] = 0;
                    cellAges[i][j] = 0;
                }
            }
        }
        
        function countNeighbors(x, y) {
            let count = 0;
            
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    
                    // Wrap around edges for seamless effect
                    const col = (x + i + cols) % cols;
                    const row = (y + j + rows) % rows;
                    
                    count += grid[col][row];
                }
            }
            
            return count;
        }
        
        function updateGrid() {
            // Apply Conway's Game of Life rules
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const neighbors = countNeighbors(i, j);
                    const state = grid[i][j];
                    
                    // Conway's rules
                    if (state === 0 && neighbors === 3) {
                        nextGrid[i][j] = 1;
                        cellAges[i][j] = 0; // New cell
                    } else if (state === 1 && (neighbors === 2 || neighbors === 3)) {
                        nextGrid[i][j] = 1;
                        cellAges[i][j] = Math.min(cellAges[i][j] + 1, 100); // Age the cell
                    } else {
                        nextGrid[i][j] = 0;
                        cellAges[i][j] = 0;
                    }
                }
            }
            
            // Mouse gravity effect - spawn cells near cursor
            const gridMouseX = Math.floor(mouseX / cellSize);
            const gridMouseY = Math.floor(mouseY / cellSize);
            const gravityRadius = 15;
            const spawnChance = 0.3;
            
            for (let i = -gravityRadius; i <= gravityRadius; i++) {
                for (let j = -gravityRadius; j <= gravityRadius; j++) {
                    const col = gridMouseX + i;
                    const row = gridMouseY + j;
                    
                    if (col >= 0 && col < cols && row >= 0 && row < rows) {
                        const distance = Math.sqrt(i * i + j * j);
                        
                        if (distance <= gravityRadius) {
                            // Higher chance to spawn closer to cursor
                            const probability = (1 - distance / gravityRadius) * spawnChance;
                            
                            if (Math.random() < probability) {
                                nextGrid[col][row] = 1;
                                cellAges[col][row] = 0;
                            }
                        }
                    }
                }
            }
            
            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];
        }
        
        function drawGrid() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Define dead zone around center for text readability
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const deadZoneWidth = 400;
            const deadZoneHeight = 250;
            
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j] === 1) {
                        const x = i * cellSize;
                        const y = j * cellSize;
                        
                        // Calculate distance from center for dead zone
                        const distFromCenterX = Math.abs(x - centerX);
                        const distFromCenterY = Math.abs(y - centerY);
                        
                        // Fade cells in the dead zone
                        let deadZoneEffect = 1;
                        if (distFromCenterX < deadZoneWidth && distFromCenterY < deadZoneHeight) {
                            const fadeX = Math.max(0, 1 - (deadZoneWidth - distFromCenterX) / deadZoneWidth);
                            const fadeY = Math.max(0, 1 - (deadZoneHeight - distFromCenterY) / deadZoneHeight);
                            deadZoneEffect = Math.max(fadeX, fadeY) * 0.3; // Reduce opacity in center
                        }
                        
                        // Calculate distance from mouse for effects
                        const dx = x - mouseX;
                        const dy = y - mouseY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Color based on age and color cycle
                        const age = cellAges[i][j];
                        const ageEffect = 1 - (age / 100) * 0.5; // Fade with age
                        
                        // HSL color cycling
                        const hue = (colorCycle + (i * 2) + (j * 2) + age * 5) % 360;
                        const saturation = 70 + (30 * ageEffect);
                        const lightness = 30 + (40 * ageEffect);
                        
                        // Brighter near mouse
                        const mouseEffect = Math.max(0, 1 - distance / 200);
                        const finalLightness = lightness + mouseEffect * 20;
                        
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${finalLightness}%, ${0.8 * ageEffect * deadZoneEffect})`;
                        
                        // Draw cell with slight size variation based on age
                        const cellSizeAdjusted = cellSize - 0.5 + (ageEffect * 0.5);
                        ctx.fillRect(x, y, cellSizeAdjusted, cellSizeAdjusted);
                        
                        // Glow effect for new cells (reduced in dead zone)
                        if (age < 5 && deadZoneEffect > 0.5) {
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = `hsla(${hue}, 100%, 60%, ${0.5 * (1 - age / 5) * deadZoneEffect})`;
                            ctx.fillRect(x, y, cellSizeAdjusted, cellSizeAdjusted);
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }
        }
        
        function drawMouseEffect() {
            // Draw gravity well effect at mouse position
            const gradient = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 80);
            const hue = colorCycle % 360;
            gradient.addColorStop(0, `hsla(${hue}, 100%, 60%, 0.1)`);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(mouseX - 80, mouseY - 80, 160, 160);
        }
        
        function animate() {
            frameCount++;
            
            // Update Game of Life every few frames for visible speed
            if (frameCount % 3 === 0) {
                updateGrid();
            }
            
            // Slowly cycle through colors
            colorCycle += 0.3;
            
            drawGrid();
            drawMouseEffect();
            
            requestAnimationFrame(animate);
        }
        
        // Spawn patterns on click
        function spawnGlider(gridX, gridY) {
            // Classic glider pattern
            const pattern = [
                [0, 1, 0],
                [0, 0, 1],
                [1, 1, 1]
            ];
            
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    const col = gridX + i - 1;
                    const row = gridY + j - 1;
                    
                    if (col >= 0 && col < cols && row >= 0 && row < rows) {
                        grid[col][row] = pattern[i][j];
                        if (pattern[i][j] === 1) {
                            cellAges[col][row] = 0;
                        }
                    }
                }
            }
        }
        
        window.addEventListener('resize', () => {
            resizeCanvas();
        });
        
        window.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        window.addEventListener('click', (e) => {
            const gridX = Math.floor(e.clientX / cellSize);
            const gridY = Math.floor(e.clientY / cellSize);
            spawnGlider(gridX, gridY);
        });
        
        // Touch support for mobile
        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
            }
        });
        
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                const gridX = Math.floor(e.touches[0].clientX / cellSize);
                const gridY = Math.floor(e.touches[0].clientY / cellSize);
                spawnGlider(gridX, gridY);
            }
        });
        
        resizeCanvas();
        animate();
    </script>
</body>
</html>